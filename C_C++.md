
# C/C++ 基础知识
> 参考：https://github.com/linw7/Skill-Tree



# 目录

| Chapter 1 | Chapter 2 | Chapter 3| Chapter 4 | 
| :---------: | :---------: | :---------: | :---------: | 
| [编程基础](base)|[面向对象基础](#oop)|[标准模板库](#stl)|[编译及调试](#other)|


# <span id = "base">编程基础</span>

## 1. c/c++中static关键字
> Linux 多线程服务端编程（陈硕）ch12.5.1 p526
### C语言的static关键字有两种用途：
* 第一种 用于函数内部修饰变量，即函数内静态变量。
这种变量的生存期长于该函数，使得函数具有一定的“状态”。使用静态变量的函数一般是不可重入的，也不是线程安全的。
* 第二种 用于文件级别（函数体之外），修饰变量和函数。
用于表示该变量或函数只在本文件可见，其他文件看不到、也访问不到该变量或函数。专业的说法叫“具有internal linkage”。
### C++语言的static关键字的四种用法：
* 第三种 用于修饰class的数据成员，即所谓“静态成员”。
这种成员的生存期大于class的对象（实体、instance）。静态数据成员是每个class有一份，普通数据成员是每个instance有一份，
因此，也分别叫做class variable和instance variable。
* 第四种 用于修饰class的成员函数，即所谓“静态成员函数”。
**这种成员函数只能访问class variable和其他静态程序函数，不能访问instance variable或instance method**。

> C++ Primer 5th P269   

类成员声明前加static，使得其与类关联在一起。    
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据.   
静态成员函数也不与任何对象绑定在一起，它们不包含this指针。  
静态成员函数 不能声明成const的。 
我们可以使用类的对象、引用或者指针来访问静态成员。  
static关键字只能出现在类内部的声明语句中    
* 类内声明有static
* 类外定义没有static

一般来说，我们不能在类的内部初始化静态成员，相反，必须在类的外部定义和初始化每个静态成员.    
要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中  
我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr.    
如果静态成员仅限于编译器使用，可以只声明而不需要在类外定义；其他情况必须定义；  
如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了；
*  error: duplicate initialization of ‘A::value’    

静态成员能用于某些场景，而普通成员不能：
* 静态成员可以是不完全类型。特别的，静态数据成员的类型可以就是它所属的类类型。
    而非静态数据成员则受到限制，只能声明成他所属类的指针或引用。
* 我们可以使用静态成员作为默认实参

## 2. new与malloc、 delete与free的区别

* malloc和free是标准库函数，支持覆盖； new和delete是运算符(关键字)，并且支持重载。
* malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险;
new和delete除了分配回收功能外，还会调用构造函数和析构函数。
* malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。
使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
* new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。
* delete和delete[]区别
    * delete只会调用一次析构函数。
    * delete[]会调用数组中每个元素的析构函数。

## 3. struct和class的区别、struct与union区别
* struct在C语言中是聚合数据类型。
* C++中两者唯一一点区别是：struct和class的默认访问权限不同。struct默认是public访问权限，而class默认private访问权限。
* 都可以继承。
* union(联合)是一种特殊的类，一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值；
* union不能含有引用类型的成员；
* union可以为其成员指定public、protected、private等保护标记；默认情况下成员都是公有的；
* union可以定义构造/析构函数在内的成员函数；
* union既不能继承自其他类，也不能作为基类使用，所以union中不能含有虚函数；

## 4. 指针和引用区别
* **引用只是别名**，不占用具体存储空间，只有声明没有定义；
* **引用在声明时必须初始化**为另一变量，一旦出现必须为typename refname &varname形式；
* 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用不能重新绑定到另外一个变量）；
* 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针（未定义）；
* 因为引用本身不是一个对象，所以不能定义引用的引用； 
* 指针本身就是一个对象，允许指针赋值和拷贝；
* 指针在生命周期内可以先后指向几个不同的对象；
* 指针无需在定义时赋值；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量；
* 可以定义指针的指针（二级指针）；
* 对引用类型执行sizeof运算得到被引用对象所占空间的大小；
* 对指针执行sizeof运算得到指针本身所占空间的大小；

## 5. sizeof运算符
> C++ Primer 5th p139   

sizeof运算符返回一条表达式或一个类型名字所占的字节数；sizeof运算符满足右结合律。    
在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用；    
sizeof运算符无须提供一个具体对象，就能知道类成员的大小；     
* 对引用类型执行sizeof运算得到被引用对象所占空间的大小；
* 对指针执行sizeof运算得到指针本身所占空间的大小；
* 对解引用指针执行sizeof运算符得到指针指向的对象所占空间的大小，指针不需有效；
* 对数组执行sizeof运算得到整个数组所占空间的大小；
* 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间；

## 6. strlen和sizeof区别

* sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
* sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
* 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。
* char str[] = "lambda"; strlen(str) = 6; sizeof(str) = 7;

## 7. 对象赋值时深拷贝和浅拷贝

类内含有指针指向的资源（动态申请的空间），当发生拷贝时，如果新对象重新分配资源，将指针所指资源复制到新对象中，这叫深拷贝；如果新对象没有重新分配资源，只是简单的拷贝指针变量，这叫浅拷贝；

## 8. 结构体内存对齐问题
> https://blog.csdn.net/dream_1996/article/details/54934334 
### 内存对齐的原因：
1. 平台原因
   不是所有硬件平台都可以访问任意地址上的任意数据； 
   某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 
2. 性能原因
  数据结构（尤其是栈）应该尽可能的在自然边界上对齐。    
  原因在于在访问未对齐的内存时，处理器需要进行两次内存访问；而对齐的内存访问仅需要一次。    

### 结构体（struct）内存对齐规则：
1. 第一个成员在与结构体变量偏移量为0的地址处。
2. 其它成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
   * 对齐数=编译器默认的一个对齐数与该成员大小的一个较小值  
   * Vs中默认的对齐数是8  
   * Linux中默认的对齐数是4   
3. 结构体总大小：最大对齐数（每个成员变量的除了第一个成员都有一个对对齐数）的整数倍。（每个成员变量在对齐之后，把成员大小加起来，再扩大到最大对齐数的整数倍）
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有对齐数（含嵌套结构体的对齐数）的整数倍。
   
* 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
* 未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。

### 编译器命令 
* // #pragma pack (n)         作用：C编译器将按照n个字节对齐。
* // #pragma pack ()          作用：取消自定义字节对齐方式。
* // #pragma  pack (push,1)   作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐
* // #pragma pack(pop)        作用：恢复对齐状态 
* 使用offsetof宏来判断结构体中成员的偏移地址。#define offsetof(type,menber) (size_t)&(((type*)0)->member)

## 9. 宏定义

### 宏定义和函数有何区别
* 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
* 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。
* 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
* 宏函数不要在最后加分号。

### 宏定义和const区别
* 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
* 宏不检查类型；const会检查数据类型。
* 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

### 宏定义和typedef区别
* 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
* 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
* 宏不检查类型；typedef会检查数据类型。
* 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
* 注意对指针的操作，typedef char* p_char 和 #define p_char char* 区别巨大。

### 宏定义和内联函数(inline)区别
* 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
* 内联函数本身是函数，强调函数特性，具有重载等功能。
* 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

### 宏定义和枚举类型（enum）
* 枚举属于字面值常量类型
* C++两种枚举:
    1. 限定作用域 enum class(或struct) 枚举名字 { 逗号分隔枚举成员};
    2. 不限定作用域 enum 枚举名字(可选) {逗号分隔枚举成员}；
* 在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外不可访问;
* 枚举成员是const,因此在初始化枚举成员时提供的初始值必须是常量表达式;
* 枚举可作为switch语句中case标签;非类型模板形参使用;等
* 可以指定enum的大小：
    1. 不限定作用域 enum intValue : unsigned long long {};
    2. 限定作用域 的enum成员默认是int;
* 前置声明: 
    1. enum intValue : unsigned long long;// 不限定作用域的必须指定成员类型
    2. enum class open_modes; // 限定作用域的枚举类型可以使用默认的成员类型int

## 10. const限定符
* const变量的值不能被改变
* const 对象声明时必须初始化    
* 默认状态下,const对象仅在文件内有效 
### const的引用
```
int i = 42;
const int &r1 = i; // 允许const int& 绑定到一个普通int对象上
const int &r2 = 42; // r2是一个常量引用
```
* 常引用可以理解为常量指针，形式为const typename & refname = varname;
* 常引用下,原变量值不会被别名所修改;
* 原变量的值可以通过原名修改;
* 常引用通常用作只读变量别名或是形参传递;
### const与指针
```
int i = 42;
const int *ptr = &i; 
```
* 指向常量的指针也没有规定其所指的对象必须是一个常量;
* 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p;
* 指针常量是一个不能给改变指向的指针。如int *const p;
```
const double pi = 3.1415926;
const double *const pip = &pi;
```
* pip是一个指向常量对象的常量指针
```
const int a;
int const a;
const int *a;
int *const a;
```
* int const a和const int a均表示定义常量类型a。
* const int * a,其中a为指向int型变量的指针, const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)
* int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)
### 顶层const与底层const
* 顶层const(top-level const)表示指针本身是个常量
* 底层const(low-level const) 表示指针所指的对象是一个常量
* const星号(*) --> 被指物是常量 --> 底层const
* 星号(*)const --> 指针本身是常量 --> 顶层const
* 声明引用的const都是底层const
```
int i = 0;
int *const p1 = &i;  // 不能改变p1的值,顶层const
const int ci = 42;   // 不能改变ci的值,顶层const
const int *p2 = &ci; // 允许改变p2的值,底层const
const int *const p3 = p2; // 靠右的const是顶层const, 靠左的const是底层const
const int &r = ci;   // 声明引用的const都是底层const
```
* 非常量可以转换成常量，反之则不行
```
int *p = p3; // 错误：p3包含底层const的定义，而p没有
p2 = p3;     // 正确：p2和p3都是底层const
p2 = &i;     // 正确：int*能转换成const int*
int &r = ci; // 错误：普通的int&不能绑定到int常量上
const int &r2 = i; // 正确：const int&可以绑定到一个普通的int上
```
### const形参与实参

当用实参初始化形参时会忽略掉顶层const.换句话,形参的顶层const被忽略掉了,当形参有顶层const时，传给它常量对象或者非常量对象都是可以的.
```
void fcn(const int i){/* fcn能够读取i,但是不能向i写值*/};
void fcn(int i){/* */}; // 错误：重复定义fcn(int)
```

## 11. 数组名和指针（这里为指向数组首元素的指针）区别

* 二者均可通过增减偏移量来访问数组中的元素。
* 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
* 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。
```
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```
* int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
* int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
* int* p(int)是函数声明(指针函数)，函数名是p，参数是int类型的，返回值是int *类型的。
* int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。
```
假设数组int a[10];
int (*p)[10] = &a;
```
* a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
* &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
* 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

## 12. 野指针是什么？

* 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。
* 产生原因及解决办法：
    * 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
    * 指针free或delete之后没有及时置空 => 释放操作后立即置空。
    * 指针操作超越了变量的作用域范围；
## 13. volatile mutable？

* volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
* 多线程中被几个任务共享的变量需要定义为volatile类型。

* 如果希望能修改类的某个数据成员，即使是在一个const成员函数内。可在变量的声明中加入mutable关键字;C++Primer5th P245
* lambda表达式中，对于一个值被拷贝的变量，lambda不会改变其值.如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。
```
void fcn() 
{
    size_t v1 = 42;
    auto f = [v1]() mutable { return ++v1; };
    ...
}
```

## 14. 堆和栈的区别？
* 申请方式不同:
    * 栈由系统自动分配;
    * 堆由程序员手动分配;
* 申请大小限制不同；
    * 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改；
    * 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整；
* 申请效率不同：
    * 栈由系统分配，速度快，不会有碎片；
    * 堆由程序员分配，速度慢，且会有碎片；

## 15. C++内存相关问题

* C++的内存布局
    * 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；
* C++内存分配方式
    * 在堆区分配,在栈区分配,静态存储区分配 (待考证)
* 重载new和delete
    * `new 表达式 执行三个步骤`
        1. 第一步 new表达式调用一个名为**operator new(或operator new[])**的标准库函数.该函数分配一个足够大的,原始的,未命名的内存空间以便存储待定类型的对象(或对象数组);
        2. 第二步 编译器运行对应的构造函数以构造这些对象,并为其传入初始值;
        3. 第三步 对象被分配空间并构造完成,返回一个指向该对象的指针;
    * `delete表达式 执行两个步骤`
        1. 第一步 对指针所指对象或者对象数组指针所指的数组中的元素执行对应的析构函数;
        2. 第二步 编译器调用名为**operator delete(或operator delete[])**的标准库函数释放内存空间;
    * `应用程序可以在全局作用域中定义operator new函数和operator delete函数,也可以将他们定义为成员函数`

## 16. 源码到可执行文件的过程
### 1. 预处理
* 预编译过程主要处理那些源代码文件中以"#"开始的预编译指令.如#include, #define等
    * 将所有的#define删除,并且展开所有的宏定义
    * 处理所有的条件预编译指令,比如#if, #ifdef, #elif, #else, #endif.
    * 处理#include预编译指令,将被包含的文件插入到该预编译指令的位置
    * 删除所有注释 // 和 /**/
    * 添加行号和文件名标识,以便于编译器编译时产生调试用的行号信息及编译产生错误或警告时显示行号.
    * 保留所有的#pragma编译指令,因为编译器需要使用他们
```
命令: 预编译器cpp  产生文件: xx.i
$gcc -E hello.c -o hello.i
或者
$cpp hello.c > hello.i
```
### 2. 编译
* 编译过程就是把预处理器处理完的文件进行一系列词法分析,语法分析,语义分析及优化后生成相应的汇编代码文件
```
命令:汇编器ccl 产生文件:xx.s
$gcc -S hello.i -o hello.s
```
### 3. 汇编
* 汇编器是将汇编代码转变成机器可以执行的指令,每一个汇编语句几乎都对应一条机器指令.
```
命令: 汇编器as 产生文件:xx.o 目标文件
$gcc -c hello.s -o hello.o
或者
$as hello.s -o hello.o
```
### 4. 链接
* 将目标文件链接为可执行程序
```
命令: 连接器ld
$ ld 
```

## 17. 可执行程序加载过程
1. 通过加载器将可执行程序加载到内存,创建程序内存映像;
    * Linux程序可通过调用execve函数来调用加载器;
    * 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中,然后通过跳转到程序的第一条指令或者入口点来运行该程序;这个将程序复制到内存并运行的过程叫做加载;
2. 在程序头部表的引导下,加载器将可执行文件的片复制到代码段和数据段.
3. 加载器跳转多程序的入口点,也就是_start函数(ctrl.o)的地址,调用系统启动函数__libc_start_main(libc.so),初始化执行环境,调用用户层的main函数,处理main函数的返回值,并且在需要的时候把控制权返回给内核;

### 程序内存分布
```
|----------------------   高地址
|    内核空间     
|----------------------  
|      栈                
|------                 ___ esp(栈指针)       栈向低地址增长
| (未使用栈空间) 
|----------------------   
|共享库内存映射区域
|----------------------
|  未使用的堆              
|
|------                 ___ brk              堆向高地址增长
|      堆     
|----------------------
|读写段(.data,.bss)
|----------------------                        由于.data段有对齐要求,所以
|只读代码段                                      代码段和数据段之间是有间隙的
|(.init,.text,.rodata)
|---------------------- 0x400000 
|              
|----------------------  低地址
```
* 代码段
    * .text 存储机器指令
* 数据段
    * .data 已初始化的全局和静态C变量,
    * .bss  未初始化的全局和静态C变量,以及所有被初始化为0的全局或静态变量;
        (在目标文件中这个节不占用实际的空间,它仅仅是一个占位符);
* 堆 
    * 动态分配的内存
* 栈
    * 局部变量

## 18. 函数栈帧及函数调用过程
* 栈保存了一个函数调用所需要的维护信息,称为堆栈帧或活动记录
* 堆栈帧一般包括如下几方面内容:
    * 函数的返回地址和参数
    * 临时变量:包括函数的非静态局部变量以及编译器自动生成的其他临时变量
    * 保存的上下文:包括在函数调用前后需要保持不变的寄存器;
```
-----|------------
  |  |   参数
  |  |
  |  |------------
  |  | 返回地址
  活 |------------  __ ebp
  动 | Old EBP
  记 |------------
  录 | 保存的寄存器
  |  |------------
  |  | 局部变量
  |  |------------
  |  | 其他数据
-----|------------ __ esp
```
* esp寄存器始终指向栈的顶部,同时也就是指向了当前函数的活动记录的顶部
* ebp寄存器指向了活动记录的一个固定位置,ebp寄存器又被称为帧指针;
### 函数调用
* 把所有或一部分参数压入栈中,如果有其他参数没有入栈,那么使用某些特定寄存器传递
* 把当前指令的下一条指令的地址压入栈中
* 跳转到函数体执行;
### 汇编
* push ebp;  // 把ebp压入栈中(称为old ebp)
* move ebp,esp; // ebp = esp (这时ebp指向栈顶,而此时栈顶就是old ebp)
* [可选] sub esp, XXX; // 在栈上分配XXX字节的临时空间
* [可选] push xxx; // 如有必要,保存名为xxx寄存器(可重复多个)
* call 
* [可选] pop xxx; // 如有必要,恢复保存名为xxx寄存器(可重复多个)
* mov esp,ebp; // 恢复ESP同时回收局部变量空间
* pop ebp; // 从栈中恢复保存的ebp的值
* ret  // 从栈中取得返回地址,并跳转到该位置








